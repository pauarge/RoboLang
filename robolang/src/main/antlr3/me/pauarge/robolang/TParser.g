parser grammar TParser;

options {

    // Default language but name it anyway
    //
    language  = Java;

    // Produce an AST
    //
    output    = AST;

    // Use a superclass to implement all helper
    // methods, instance variables and overrides
    // of ANTLR default methods, such as error
    // handling.
    //
    superClass = AbstractTParser;

    // Use the vocabulary generated by the accompanying
    // lexer. Maven knows how to work out the relationship
    // between the lexer and parser and will build the 
    // lexer before the parser. It will also rebuild the
    // parser if the lexer changes.
    //
    tokenVocab = TLexer;
}

// Import a grammar file, even though it does not really need it in this
// simle demo parser. We do the import to show where imported grammars should be
// stored for maven builds.
//


// Some imaginary tokens for tree rewrites
//
tokens {
    LIST_INSTR;
    FUNCTION;
    PARAMS;
    COND;
    PARAMS;
    PREF;
    PVALUE;
}

// What package should the generated source exist in?
//
@header {
    package me.pauarge.robolang;
}

prog        :   list_instr -> ^(LIST_INSTR list_instr) ;

list_instr  :   (instr)+ ;

instr       :   loop
            |   ifst
            |   assign SEMI!
            |   func
            |   funcall SEMI!
            ;

assign      :   ident ASSIGN^ expr ;

ident       :   VAR^ | (DOLLAR^ VAR) ;

func        :   DEF VAR LPAR params RPAR LBRA list_instr RETURN? RBRA -> ^(DEF VAR params ^(LIST_INSTR list_instr)) ;

params      :   list_param? -> ^(PARAMS list_param?) ;

list_param  :   param (COMA! param)* ;

param       :   REF id=ID -> ^(PREF[$id,$id.text])
            |   id=ID -> ^(PVALUE[$id,$id.text])
            ;

cond        :   ifst elifst elsest? -> ^(COND ifst elifst elsest?) ;            

ifst        :   IF^ LPAR! expr RPAR! LBRA! list_instr RBRA! ;

elifst      :   (ELIF^ LPAR! expr RPAR! LBRA! list_instr RBRA!)* ;

elsest      :   ELSE^ LBRA! list_instr RBRA! ;
            
loop        :   WHILE^ LPAR! expr RPAR! LBRA! list_instr RBRA! ;

expr        :   boolterm (OR^ boolterm)* ;

boolterm    :   boolfact (AND^ boolfact)* ;

boolfact    :   num_expr ((EQUAL^ | NOT_EQUAL^ | LT^ | LE^ | GT^ | GE^) num_expr)? ;

num_expr    :   term ( (ADD^ | SUB^) term)* ;

term        :   factor ( (TIMES^ | DIV^ | MOD^) factor)* ;

factor      :   (ADD^ | SUB^)? atom ;

atom        :   VAR
            |   funcall
            |   NUM
            |   DOLLAR^ VAR
            ;

funcall     :   VAR LPAR expr_list? RPAR -> ^(FUNCTION VAR ^(PARAMS expr_list?)) ;
expr_list   :   expr (COMMA! expr)* ;
