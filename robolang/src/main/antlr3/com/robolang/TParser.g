parser grammar TParser;

options {

    // Default language but name it anyway
    //
    language  = Java;

    // Produce an AST
    //
    output    = AST;

    // Use the vocabulary generated by the accompanying
    // lexer. Maven knows how to work out the relationship
    // between the lexer and parser and will build the 
    // lexer before the parser. It will also rebuild the
    // parser if the lexer changes.
    //
    tokenVocab = TLexer;
}

// Import a grammar file, even though it does not really need it in this
// simle demo parser. We do the import to show where imported grammars should be
// stored for maven builds.
//


// Some imaginary tokens for tree rewrites
//
tokens {
    LIST_INSTR;
    FUNCTION;
    FUNCALL;
    PARAMS;
    COND;
    PARAMS;
    PREF;
    ARRAY;
    PVALUE;
    ARRAY_EXPR;
}

// What package should the generated source exist in?
//
@header {
    package com.robolang;
}

prog        :   list_instr -> ^(LIST_INSTR list_instr) ;

list_instr  :   (instr)+ ;

instr       :   loop
            |   cond
            |   assign SEMI!
            |   func
            |   funcall SEMI!
            |   forst
            ;

assign      :   ident ASSIGN expr -> ^(ASSIGN ident expr);

array_expr  :   VAR LCOR expr RCOR -> ^(ARRAY_EXPR VAR expr);

array       :   LCOR array2 RCOR -> ^(ARRAY array2);

array2      :   MR (COMMA! MR)* ;

ident       :   (VAR^ | (DOLLAR^ VAR) | array_expr) ;

func        :   DEF VAR LPAR params RPAR LBRA list_instr ret? RBRA -> ^(FUNCTION VAR params ^(LIST_INSTR list_instr) ret?) ;

ret         :   (RETURN expr SEMI);

params      :   list_param? -> ^(PARAMS list_param?) ;

list_param  :   param (COMMA! param)* ;

param       :   REF id=VAR -> ^(PREF[$id,$id.text])
            |   id=VAR -> ^(PVALUE[$id,$id.text])
            ;

cond        :   cond2 -> ^(COND cond2);

cond2       :   ifst elifst* elsest?;

ifst        :   IF LPAR expr RPAR LBRA list_instr RBRA -> ^(IF expr ^(LIST_INSTR list_instr)) ;

elifst      :   ELIF LPAR expr RPAR LBRA list_instr RBRA -> ^(ELIF expr ^(LIST_INSTR list_instr));

elsest      :   ELSE LBRA list_instr RBRA -> ^(ELSE ^(LIST_INSTR list_instr));

forst       :   FOR LPAR VAR IN forst2 RPAR LBRA list_instr RBRA -> ^(FOR VAR forst2 ^(LIST_INSTR list_instr));

forst2      :   array | VAR;
            
loop        :   WHILE LPAR expr RPAR LBRA list_instr RBRA -> ^(WHILE expr ^(LIST_INSTR list_instr));

expr        :   boolterm (OR^ boolterm)* ;

boolterm    :   boolfact (AND^ boolfact)* ;

boolfact    :   TRUE | FALSE | num_expr ((EQ^ | NEQ^ | LT^ | LET^ | GT^ | GET^) num_expr)? ;

num_expr    :   term ( (ADD^ | SUB^) term)* ;

term        :   factor ( (TIMES^ | DIV^ | MOD^) factor)* ;

factor      :   (ADD^ | SUB^)? atom ;

atom        :   VAR
            |   funcall
            |   NUM
            |   array
            |   array_expr
            |   DOLLAR^ VAR
            |   LPAR! expr RPAR!
            ;

funcall     :   VAR LPAR expr_list? RPAR -> ^(FUNCALL VAR ^(PARAMS expr_list?)) ;
expr_list   :   expr (COMMA! expr)* ;
